//----------------------------------------------------------------------
//author:wly
//time:
//dsc:封装模拟相机
//
//----------------------------------------------------------------------

#ifndef DCVIEW_CAMERA
#define DCVIEW_CAMERA

//#include "QtOpenGL/QGLWidget"
#include "QObject"

//DCCore
#include "DCCore/BasicTypes.h"

#include "ViewDLL.h"
#include "Viewport.h"

namespace DCView
{
  class AABB;
  typedef enum
  {
	  PMT_UserProjection,              //!< Unknown or other projection type.
	  PMT_OrthographicProjection,      //!< Projection matrix generated by mat4::getOrtho() or similar. Any orthographic projection.
	  PMT_PerspectiveProjection,       //!< Projection matrix generated by mat4::getPerspective() or similar. Symmetrical (on-axis) perspective projection.
	  PMT_PerspectiveProjectionFrustum //!< Projection matrix generated by mat4::getFrustum() or similar. Possibly asymmetrical (off-axis) perspetive projection, like the ones used for tile-rendering.
  } EProjectionMatrixType;

  class DC_VIEW_API Camera : public QObject
  {
	  Q_OBJECT
  public:
    /** Constructs a perspective projecting camera with FOV = 60.0, Near Plane = 0.05, Far Plane = 10000.0 */
    Camera();
	~Camera();

    /** Computes the Camera's frustum planes in world space.
    If nearFarClippingPlanesOptimized() == true the near and far culling planes distances 
    are respectively set to nearPlane() and farPlane(). */
    void computeFrustumPlanes();

    /** Loads the GL_MODELVIEW matrix with the Camera's view matrix multiplied by the specified model matrix. */
    void applyModelViewMatrix(const DCCore::mat4& model_matrix) const;

    /** Loads the GL_MODELVIEW matrix with the Camera's view matrix. */
    void applyViewMatrix() const;

    /** Loads the GL_PROJECTION matrix with the Camera's projection matrix. */
    void applyProjMatrix() const;

    /** Returns the aspect ratio computed as viewport()->width()/viewport()->height(). 
    If viewport() == NULL the function returns 0. */
    float aspectRatio() const 
    {
      if (viewport())
        return (float)viewport()->width()/viewport()->height();
      else
        return 0;
    }

    /** The field of view of the camera. 
    \note This setting will not take effect until setProjectionPerspective() is called. */
    void setFOV(float fov) { mFOV = fov; }
    
    /** The field of view of the camera. */
    float fov() const { return mFOV; }

    /** The near clipping plane.
    \note This setting will not take effect until setProjectionPerspective() or setProjectionOrtho() is called. */
    void setNearPlane(float nearplane) { mNearPlane = nearplane; }

    /** The near clipping plane. */
    float nearPlane() const { return mNearPlane; }

    /** The far clipping plane. 
    \note This setting will not take effect until setProjectionPerspective() or setProjectionOrtho() is called. */
    void setFarPlane(float farplane) { mFarPlane = farplane; }

    /** The far clipping plane. */
    float farPlane() const { return mFarPlane; }

    /** 'left' parameter as passed to the last setProjectionFrustum() or setProjectionOrtho*() */
    float left() const { return mLeft; }
    void setLeft(float v) { mLeft = v; }

    /** 'right' parameter as passed to the last setProjectionFrustum() or setProjectionOrtho*() */
    float right() const { return mRight; }
    void setRight(float v) { mRight = v; }

    /** 'bottom' parameter as passed to the last setProjectionFrustum() or setProjectionOrtho*() */
    float bottom() const { return mBottom; }
    void setBottom(float v) { mBottom = v; }

    /** 'top' parameter as passed to the last setProjectionFrustum() or setProjectionOrtho*() */
    float top() const { return mTop; }
    void setTop(float v) { mTop = v; }

    /** The viewport bound to a camera. */
    void setViewport(Viewport* viewport) { mViewport = viewport; }

    /** The viewport bound to a camera. */
    Viewport* viewport() { return mViewport; }

    /** The viewport bound to a camera. */
    const Viewport* viewport() const { return mViewport; }

    /** Sets the Camera's view matrix (inverse of the modeling matrix). The modelingMatrix() is also set as the inverse of the viewMatrix().
        @remarks The modelingMatrix() bring points from camera space to world space, where the viewMatrix() brings points from world space to camera space. */
    void setViewMatrix(const DCCore::mat4& mat) { mViewMatrix = mat; mViewMatrix.getInverse(mModelingMatrix); }

    /** Returns the Camera's view matrix (inverse of the modeling matrix). This is what you would pass to OpenGL with "glMatrixMode(GL_MODELVIEW); glLoadMatrix(camera.viewMatrix().ptr());"
        @remarks The modelingMatrix() bring points from camera space to world space, where the viewMatrix() brings points from world space to camera space. */
    const DCCore::mat4& viewMatrix() const { return mViewMatrix; }

    /** Sets the Camera's modelingMatrix() (inverse of the view matrix). The view matrix is also set as the inverse of the modelingMatrix().
        @remarks The modelingMatrix() bring points from camera space to world space, where the viewMatrix() brings points from world space to camera space. */
    void setModelingMatrix(const DCCore::mat4& mat) { mModelingMatrix = mat; mModelingMatrix.getInverse(mViewMatrix); }

    /** Returns the Camera's modelingMatrix() (inverse of the view matrix).
        @remarks The modelingMatrix() bring points from camera space to world space, where the viewMatrix() brings points from world space to camera space. */
    const DCCore::mat4& modelingMatrix() const { return mModelingMatrix; }

    /** The Camera's projection matrix. */
    void setProjectionMatrix(const DCCore::mat4& mat, EProjectionMatrixType proj_type) { mProjectionMatrix = mat; mProjectionType = proj_type; }

    /** The Camera's projection matrix. */
    const DCCore::mat4& projectionMatrix() const { return mProjectionMatrix; }

    /** The Camera's projection matrix type. */
    EProjectionMatrixType projectionMatrixType() const { return mProjectionType; }

    /** Builds a perspective projection matrix for the Camera based on the Camera's and Viewport's settings. 
    See also http://www.opengl.org/sdk/docs/man/xhtml/gluPerspective.xml for more information. */
    void setProjectionPerspective();

    /** Builds a perspective projection matrix for the Camera based on the Camera's and Viewport's settings. 
    See also http://www.opengl.org/sdk/docs/man/xhtml/gluPerspective.xml for more information. */
    void setProjectionPerspective(float fov, float near, float far);

    /** Produces a perspective projection matrix. 
    The <left, bottom, zfar> and <right, top, znear> parameters specify the points on the near clipping plane that are mapped to the lower-left and upper-right corners of the viewport, 
    respectively, assuming that the eye is located at (0,0,0). The zfar parameter specifies the location of the far clipping plane. Both znear and zfar must be positive.

    This function is more general that setProjectionPerspective() as it's capable of generating off-axis projections, while setProjectionPerspective() only produces 
    symmetrical (on-axis) projections. Since setProjectionFrustum() is more general than setProjectionPerspective(), you can use it in cases where setProjectionPerspective() 
    can't be used. Some examples include shadows projection, tiled renderings, and stereo views.
    \sa
    - http://www.opengl.org/sdk/docs/man/xhtml/glFrustum.xml 
    - http://www.opengl.org/resources/faq/technical/transformations.htm */
    void setProjectionFrustum(float left, float right, float bottom, float top, float znear, float zfar);

    /** Builds an orthographic projection matrix for the Camera based on the Camera's near/far planes and its Viewport's settings. 
    - See also http://www.opengl.org/sdk/docs/man/xhtml/glOrtho.xml and http://www.opengl.org/sdk/docs/man/xhtml/glOrtho2D.xml for more information.
    Equivalent to:
    \code
    setProjectionMatrix( mat4::getOrtho(left, right, bottom, top, znear, zfar), PMT_OrthographicProjection );
    \endcode */
    void setProjectionOrtho(float left, float right, float bottom, float top, float znear, float zfar);

    /** Builds an orthographic projection matrix for the Camera based on the Camera's near/far planes and its Viewport's settings. 
    - See also http://www.opengl.org/sdk/docs/man/xhtml/glOrtho.xml and http://www.opengl.org/sdk/docs/man/xhtml/glOrtho2D.xml for more information.
    Equivalent to:
    \code
    setProjectionMatrix( mat4::getOrtho(0, viewport()->width(), 0, viewport()->height(), nearPlane(), farPlane()), PMT_OrthographicProjection );
    \endcode */
    void setProjectionOrtho();

    /** Builds an orthographic projection matrix for the Camera based on the Camera's near/far planes and its Viewport's settings. 
    This function is similar to glOrtho2D() with the difference that it can optionally add a translation offset on both x and y. For example with
    an offset of -0.5 the center of the pixels will be exactly at integer coordinates 0, 1, 2, etc.
    - See also http://www.opengl.org/sdk/docs/man/xhtml/glOrtho.xml and http://www.opengl.org/sdk/docs/man/xhtml/glOrtho2D.xml for more information.
    Equivalent to:
    \code
    setProjectionMatrix( mat4::getOrtho(offset, viewport()->width() + offset, offset, viewport()->height() + offset, -1.0, +1.0), PMT_OrthographicProjection );
    \endcode */
    void setProjectionOrtho(float offset);

    /** Setup the modelview transform of the camera based on look-at parameters. 
    \param eye The position of the camera.
    \param center The point the camera is looking at.
    \param up The vector defining the up direction. */
    void setViewMatrixLookAt(const DCVector3D& eye, const DCVector3D& at, const DCVector3D& up);

    /** Returns the look-at parameters of the modelview transform.
    \param eye The position of the camera.
    \param look The direction the camera is looking at.
    \param up The vector defining the Y positive direction of the camera.
    \param right The vector defining the X positive direction of the camera. */
    void getViewMatrixAsLookAt(DCVector3D& eye, DCVector3D& at, DCVector3D& up, DCVector3D& right) const;

    /** Projects a vector from world coordinates to viewport coordinates. */
    bool project(const vec4& in_world, vec4& out_viewp) const;

    /** Unprojects a vector from viewport coordinates to world coordinates.
    \param in_viewp The viewport coordinates point to be projected. Note that, in accordance to OpenGL conventions, 
    the viewport  coordinates have the Y axis pointing upwards and origin at the bottom left corner of the viewport.
    \param out_world The world coordinates of the projected point.
    \note The \p z coordinate of \p in_viewp determines the position of the projected point along the ray passing through \p in_viewp. 
    If \p z equals 0 then \p out_world will lay on the near clipping plane, if \p z equals 1 then \p out_world will lay on the far clipping plane. */
    bool unproject(const DCVector3D& in_viewp, vec4& out_world) const;

    /** Unprojects a set of points. See unproject(const DCVector3D& in_viewp, vec4& out_world) for more information. */
    bool unproject(std::vector<DCVector3D>& points) const;

    /** Adjusts the camera position so that the given aabb can be properly viewed.
    \param aabb The AABB (in world coords) that should be visible from the newly computed camera position.
    \param dir The direction (in world coords) along which the camera should be displaced to view the given AABB.
    \param up The vector that defines the \p up direction (in world coords). Used to properly compute the new camera matrix.
    \param bias A bias factor used to adjust the computed camera distance from the given AABB. Values between 0 and 1 make the camera closer to the AABB center, values greater than 1 position the camera further away. */
    void adjustView(const AABB& aabb, const DCVector3D& dir, const DCVector3D& up, float bias=1.0f);

  protected:
    DCCore::mat4 mViewMatrix;
    DCCore::mat4 mModelingMatrix;
    DCCore::mat4 mProjectionMatrix;
    Viewport* mViewport;

    float mFOV;
    float mLeft, mRight, mBottom, mTop;
    float mNearPlane;
    float mFarPlane;
    EProjectionMatrixType mProjectionType;
  };
}

#endif
